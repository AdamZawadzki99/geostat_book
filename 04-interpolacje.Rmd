
# Metody interpolacji {#metody-interpolacji}

Odtworzenie obliczeń z tego rozdziału wymaga załączenia poniższych pakietów oraz wczytania poniższych danych:

```{r, interpolate_inits, message=FALSE, warning=FALSE}
library(dismo)
library(raster)
library(sp)
library(gstat)
library(fields)
library(geostatbook)
library(deldir)
library(rgeos)
data(punkty)
data(siatka)
data(granica)
```

```{r, echo=FALSE}
par(mar = c(rep(0, 4)))
```

Przez przejściem do interpolacji geostatystycznych warto zdać sobie sprawę, że nie jest to jedyna możliwa droga postępowania do stworzenia predykcji przestrzennych. 
Można wyróżnić dwie główne grupy modeli przestrzennych - modele deterministyczne oraz modele statystyczne.

## Tworzenie siatek

W większości przypadków analiz geostatystycznych konieczne jest stworzenie siatki interpolacyjnej (pustego rastra).
Istnieją dwa podstawowe rodzaje takich siatek - siatki regularne oraz siatki nieregularne.

### Siatki regularne

Siatki regularne mają kształt prostokąta obejmującego cały analizowany obszar. 
Określenie granic obszaru można wykonać na podstawie zasięgu danych punktowych za pomocą funkcji `st_bbox()` z pakietu **sf** lub funkcji `extent()` z pakietu **raster**.

```{r}
st_bbox(dane_punktowe_sf)
extent(dane_punktowe_sf)
```

Do stworzenia siatki można użyć funkcji `expand.grid()`.
Wymaga ona określenia dwóch argumentów - `x` oraz `y` (taka ich nazwa nie jest obowiązkowa). 
Oba argumenty przyjmują trzy wartości: (i) `from` oznaczający wartość początkową współrzędnej, (ii) `to` określający wartość końcową współrzędnej, oraz (iii) `by` określający rozdzielczość. 
Przy ustalaniu wartości początkowej i końcowej konieczne jest ich rozszerzenie względem wartości z funkcji `bbox()` lub `extent()`, aby wszystkie analizowane punkty znalazły się na badanym obszarze. 

```{r }
siatka <- expand.grid(
  x = seq(from = 745050, to = 757050, by = 500),
  y = seq(from = 712650, to = 721650, by = 500)
)
```

Utworzony w ten sposób obiekt wymaga określenia współrzędnych (funkcja `coordinates()`), potwierdzenia że dane mają być siatką (funkcja `gridded()`), oraz przypisania układu współrzędnych z obiektu punktowego (funkcja `proj4string()`).

```{r }
coordinates(siatka) <- ~x + y
gridded(siatka) <- TRUE
proj4string(siatka) <- proj4string(dane_punktowe)
```

Alternatywnie, do stworzenia siatki można wykorzystać funkcję `makegrid()`.
Tworzy ona nowy obiekt na podstawie istniejącego obiektu punktowego oraz zadanej rozdzielczości. 

```{r}
siatka <- makegrid(dane_punktowe, cellsize = 500)
names(siatka) <- c("x", "y")
coordinates(siatka) <- ~x + y
gridded(siatka) <- TRUE
proj4string(siatka) <- proj4string(dane_punktowe)
```

### Siatki regularne

Sprawdzenie, czy uzyskana siatka oraz dane punktowe się na siebie nakładają można sprawdzić za pomocą funkcji `plot()`. 
W poniższym przykładzie, pierwszy wiersz służy wyświetleniu siatki, a drugi dodaje dane punktowe z użyciem argumentu `add`.

```{r }
plot(siatka)
plot(dane_punktowe, add = TRUE)
```

### Siatki nieregularne - klasa `RasterLayer`

Siatki nieregularne mają zazwyczaj kształt wieloboku obejmującego analizowany obszar. 
Mogą one powstać, np. w oparciu o wcześniej istniejące granice.
Siatki nieregularne w R mają zazwyczaj klasę `RasterLayer` lub `SpatialPixelsDataFrame`. 
Pierwsza z klas jest elastyczniejsza i prostsza w użyciu, podczas gdy druga jest lepiej wspierana przez funkcje geostatystyczne, np. z pakietu **gstat**.

W poniższym przypadku odczytywana jest granica badanego obszaru z pliku GeoPackage.
Taki obiekt można np. stworzyć za pomocą oprogramowania gisowego takiego jak [QGIS](http://www.qgis.org/pl/site/).
Następnie na podstawie tego obiektu tworzony jest obiekt klasy `RasterLayer`, a za pomocą funkcji `res()` definiowana jest jego rozdzielczość.
W kolejnym kroku ustala się wartość wszystkich oczek siatki na zero, oraz poprzez funkcję `proj4string()` ujednolica się definicję układu współrzędnych siatki. 
Ostatnim krokiem jest przycięcie siatki do nieregularnego obszaru z użyciem funkcji `mask()`.

```{r siatkaniereg, warning=FALSE}
granica <- st_read("dane/granica.gpkg")
siatka_n <- raster(extent(granica))
res(siatka_n) <- c(250, 250)
siatka_n[] <- 0
proj4string(siatka_n) <- st_crs(granica)$proj4string
siatka_n <- mask(siatka_n, granica)
```

Wynik przetworzenia można zobaczyć z użyciem funkcji `levelplot`.

```{r }
levelplot(siatka_n, margin = FALSE)
```

### Siatki nieregularne - klasa `SpatialPixelsDataFrame`

Nieregularną siatkę klasy `RasterLayer` łatwo jest przetworzyć do klasy `SpatialPixelsDataFrame`. 

```{r }
siatka_n <- as(siatka_n, "SpatialPointsDataFrame")
siatka_n <- siatka_n[!is.na(siatka_n@data$layer), ]
gridded(siatka_n) <- TRUE
plot(siatka_n)
```

```{r, echo=FALSE, eval=FALSE}
zip("dane.zip", "dane")
```

## Modele deterministyczne

Modele deterministyczne charakteryzują się tym, że ich parametry są zazwyczaj ustalane w oparciu o funkcję odległości lub powierzchni. 
W tych modelach brakuje szacunków na temat oceny błędu modelu.
Zaletą tych modeli jest ich prosta oraz krótki czas obliczeń. 
Do modeli deterministycznych należą, między innymi:

- Metoda diagramów Voronoi'a (ang.  *Voronoi diagram*)
- Metoda średniej ważonej odległością (ang. *Inverse Distance Weighted - IDW*)
- Funkcje wielomianowe (ang. *Polynomials*)
- Funkcje sklejane (ang. *Splines*)

<!--http://neondataskills.org/Data-Workshops/ESA15-Going-On-The-Grid-Spatial-Interpolation-Basics/-->

### Modele deterministyczne | Voronoi

Metoda diagramów Voronoi'a polega na stworzeniu nieregularnych poligonów na podstawie analizowanych punktów, a następnie wpisaniu w każdy poligon wartości odpowiadającego punktu. 
Na poniższym przykładzie ta metoda stosowana jest z użyciem funkcji `voronoi()` z pakietu **dismo**.
Wyniki następnie można przyciąć do badanego obszaru z użyciem funkcji `intersect()` z pakietu **raster**.

```{r }
voronoi_interp <- voronoi(punkty) 
plot(voronoi_interp, main = "Poligony Voronoia")
spplot(voronoi_interp, zcol = "temp", main = "Poligony Voronoia - temperatura")
```

### Modele deterministyczne | IDW

Metoda średniej ważonej odległością (IDW) wylicza wartość dla każdej komórki na podstawie wartości punktów obokległych ważonych odwrotnością ich odległości. 
W efekcie, czym bardziej jest punkt oddalony, tym mniejszy jest jego wpływ na interpolowaną wartość. 
Wagę punktów ustala się z użyciem argumentu wykładnika potęgowego (ang. *power*).
W pakiecie **gstat** istnieje do tego celu funkcja `idw()`, która przyjmuje analizowaną cechę (`temp~1`), zbiór punktowy, siatkę, oraz wartość wykładnika potęgowego (argument `idp`).

```{r }
idw_wolin <- idw(temp~1, locations = punkty, newdata = siatka, idp = 2)
spplot(idw_wolin, zcol = "var1.pred", contour = TRUE, main = "IDW")
```

<!--
dodaj wykresy idw
https://rpubs.com/DonalOLeary/80504
-->

### Modele deterministyczne | Funkcje wielomianowe

Stosowanie funkcji wielomianowych w R może odbyć się z wykorzystaniem funkcji `gstat()` z pakietu **gstat**.
Wymaga ona podania trzech argumentów: `formula` określającego naszą analizowaną cechę (`temp~1` mówi, że chcemy interpolować wartość temperatury zależnej od samej siebie), `data` określający analizowany zbiór danych, oraz `degree` określającą stopień wielomianu.
Następnie funkcja `predict()` przenosi nowe wartości na wcześniej stworzoną siatkę.

```{r }
# wielomian 1 stopnia
wielomian_1 <- gstat(formula = temp~1, locations = punkty, degree = 1)
wielomian_1_pred <- predict(wielomian_1, newdata = siatka)
spplot(wielomian_1_pred, zcol = "var1.pred", contour = TRUE, main = "Powierzchnia trendu - wielomian pierwszego stopnia")
# wielomian 2 stopnia
wielomian_2 <- gstat(formula = temp~1, locations = punkty, degree = 2)
wielomian_2_pred <- predict(wielomian_2, newdata = siatka)
spplot(wielomian_2_pred, zcol = "var1.pred", contour = TRUE, main = "Powierzchnia trendu - wielomian drugiego stopnia")
# wielomian 3 stopnia
wielomian_3 <- gstat(formula = temp~1, locations = punkty, degree = 3)
wielomian_3_pred <- predict(wielomian_3, newdata = siatka)
spplot(wielomian_3_pred, zcol = "var1.pred", contour = TRUE, main = "Powierzchnia trendu - wielomian trzeciego stopnia")
```

### Modele deterministyczne | Funkcje sklejane

Interpolacja z użyciem funkcji sklejanych (funkcja `Tps()` z pakietu **fields**) dopasowuje krzywą powierzchnię do wartości analizowanych punktów.

```{r }
tps <- Tps(coordinates(punkty), punkty$temp)
ras <- raster(siatka)
spline <- interpolate(ras, tps)
spline <- mask(spline, ras)
spplot(spline, contour = TRUE, main = "Funkcje sklejane")
```

### Modele deterministyczne | Porównanie

```{r echo=FALSE}
library(gridExtra)
p1 <- spplot(wielomian_3_pred[1], main = "Wielomiany")
p2 <- spplot(spline, main = "Funkcje sklejane")
p3 <- spplot(voronoi_interp, "temp", main = "Poligony Voronoia")
p4 <- spplot(idw_wolin, "var1.pred", main = "IDW")
grid.arrange(p3, p4, p1, p2)
```

## Modele statystyczne

Modele statystyczne charakteryzują się tym, że ich parametry określane są w oparciu o teorię prawdopodobieństwa.
Dodatkowo wynik estymacji zawiera także oszacowanie błędu, jednak te metody zazwyczaj wymagają większych zasobów sprzętowych.
Do modeli statystycznych należą, między innymi:

- Kriging
- Modele regresyjne
- Modele bayesowe
- Modele hybrydowe

W kolejnych rozdziałach można znaleźć omówienie kilku podstawowych typów pierwszej z tych metod - krigingu.
